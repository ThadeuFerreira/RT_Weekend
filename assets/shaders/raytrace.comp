#version 430 core
// =============================================================
// raytrace.comp — GPU path tracer (compute shader)
// =============================================================
//
// This shader implements the same algorithm as the CPU renderer
// (raytrace/vector3.odin::ray_color) but using:
//   • Iterative path tracing (GLSL has no recursion)
//   • PCG hash RNG (parallel-safe, per-invocation state)
//   • Iterative BVH traversal (the same flat LinearBVHNode array
//     built by flatten_bvh in hittable.odin)
//
// Workgroup: 8×8 threads — 64 threads per tile, matching typical
// GPU warp/wavefront sizes for good occupancy.
//
// Progressive rendering: call one dispatch per sample.
// The output SSBO accumulates RGB values; the CPU reads back and
// divides by the sample count to produce the final image.
//
// ─── Bindings ────────────────────────────────────────────────
//   binding=0  CameraBlock   (UBO, std140)  — camera parameters
//   binding=1  SpheresBlock  (SSBO, std430) — sphere array
//   binding=2  BVHBlock      (SSBO, std430) — LinearBVHNode array
//   binding=3  OutputBlock   (SSBO, std430) — vec4 accumulation buffer
// ─────────────────────────────────────────────────────────────

layout(local_size_x = 8, local_size_y = 8) in;

// =============================================================
// Binding 0 — Camera parameters (UBO, std140)
// Must match GPUCameraUniforms in raytrace/gpu_types.odin exactly.
// vec3 fields are padded to vec4 as required by std140.
// =============================================================
layout(std140, binding = 0) uniform CameraBlock {
    vec4 camera_center;     // .xyz = position,       .w = unused
    vec4 pixel00_loc;       // .xyz = top-left pixel, .w = unused
    vec4 pixel_delta_u;     // .xyz = per-pixel u step
    vec4 pixel_delta_v;     // .xyz = per-pixel v step
    vec4 defocus_disk_u;    // .xyz = defocus disk u, .w = defocus_angle
    vec4 defocus_disk_v;    // .xyz = defocus disk v, .w = unused
    int  width;
    int  height;
    int  max_depth;
    int  total_samples;
    int  current_sample;
    int  _pad0, _pad1, _pad2;
};

// =============================================================
// Binding 1 — Sphere array (SSBO, std430)
// Matches GPUSphere in raytrace/gpu_types.odin.
// 48 bytes per sphere.
// =============================================================

// Material type constants — mirror MAT_* in gpu_types.odin.
// Adding a new material: add a constant here, a case in path_trace(),
// and the corresponding scatter_* procedure below.
const int MAT_LAMBERTIAN = 0;
const int MAT_METALLIC   = 1;
const int MAT_DIELECTRIC = 2;

struct Sphere {
    vec3  center;
    float radius;
    vec3  albedo;
    int   mat_type;
    float fuzz_or_ior;  // fuzz (metallic) or index of refraction (dielectric)
    float _pad[3];
};

layout(std430, binding = 1) readonly buffer SpheresBlock {
    int    sphere_count;
    int    _sphere_pad[3];
    Sphere spheres[];
};

// =============================================================
// Binding 2 — Linear BVH nodes (SSBO, std430)
// Matches LinearBVHNode in raytrace/gpu_types.odin.
// 32 bytes per node.
// Leaf:     left_idx = -1,  right_or_obj_idx = -(obj_index + 1)
// Internal: left_idx = left child, right_or_obj_idx = right child
// =============================================================
struct BVHNode {
    vec3 aabb_min;
    int  right_or_obj_idx;
    vec3 aabb_max;
    int  left_idx;
};

layout(std430, binding = 2) readonly buffer BVHBlock {
    int     bvh_count;
    int     _bvh_pad[3];
    BVHNode bvh_nodes[];
};

// =============================================================
// Binding 3 — Output accumulation buffer (SSBO, std430)
// vec4 per pixel (intentional: std430 vec3 would need careful padding;
// .rgb = accumulated linear colour, .a unused). After N samples:
// colour = buffer[idx].rgb / N, then gamma-correct.
// =============================================================
layout(std430, binding = 3) buffer OutputBlock {
    vec4 pixels[];
};

// =============================================================
// PCG hash RNG
// =============================================================
// Permuted Congruential Generator — compact, high quality, and
// safe for parallel use because each invocation carries its own
// state in a local uint (no shared globals).
//
// Seed per invocation: combine pixel index and sample index then hash once.
// Using pcg_hash(combined) avoids additive correlation between consecutive
// pixels that a linear formula (e.g. pixel*P + sample*Q) would give.

uint pcg_hash(uint v) {
    v = v * 747796405u + 2891336453u;
    uint word = ((v >> ((v >> 28u) + 4u)) ^ v) * 277803737u;
    return (word >> 22u) ^ word;
}

uint pcg(inout uint state) {
    // LCG step — advances the state.
    state = state * 747796405u + 2891336453u;
    // XOR-shift and rotation mix step (permutation).
    uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;
    return (word >> 22u) ^ word;
}

// rand() returns a uniform float in [0, 1).
float rand(inout uint seed) {
    return float(pcg(seed)) / float(0xFFFFFFFFu);
}

// rand2() returns two independent uniform floats.
vec2 rand2(inout uint seed) {
    return vec2(rand(seed), rand(seed));
}

// rand_unit_vec3 returns a random unit vector (uniform on the sphere).
// Uses the rejection method: pick a random point in the unit cube,
// reject if outside the unit sphere, then normalize.
vec3 rand_unit_vec3(inout uint seed) {
    for (int i = 0; i < 16; i++) {
        vec3 p = vec3(rand(seed), rand(seed), rand(seed)) * 2.0 - 1.0;
        float lsq = dot(p, p);
        if (lsq <= 1.0 && lsq > 1e-8) return p / sqrt(lsq);
    }
    return vec3(0, 1, 0); // fallback (astronomically unlikely)
}

// rand_in_unit_disk returns a random point in the unit disk (z=0).
// Used for depth-of-field / defocus blur.
vec2 rand_in_unit_disk(inout uint seed) {
    for (int i = 0; i < 16; i++) {
        vec2 p = rand2(seed) * 2.0 - 1.0;
        if (dot(p, p) < 1.0) return p;
    }
    return vec2(0); // fallback
}

// =============================================================
// Ray / intersection helpers
// =============================================================

struct Ray {
    vec3 origin;
    vec3 dir;
};

vec3 ray_at(Ray r, float t) {
    return r.origin + t * r.dir;
}

struct HitRecord {
    vec3  p;          // hit point in world space
    vec3  normal;     // outward normal at hit point
    float t;          // ray parameter at hit
    bool  front_face; // true if ray hit the outside of the surface
    int   mat_type;
    vec3  albedo;
    float fuzz_or_ior;
};

// set_face_normal ensures the stored normal always points against the ray.
void set_face_normal(inout HitRecord rec, Ray r, vec3 outward_normal) {
    rec.front_face = dot(r.dir, outward_normal) < 0.0;
    rec.normal = rec.front_face ? outward_normal : -outward_normal;
}

// hit_sphere tests a ray against a sphere using the quadratic formula.
// Returns true and fills rec if the ray hits in [t_min, t_max].
bool hit_sphere(Sphere s, Ray r, float t_min, float t_max, out HitRecord rec) {
    vec3  oc = s.center - r.origin;
    float a  = dot(r.dir, r.dir);
    float h  = dot(r.dir, oc);
    float c  = dot(oc, oc) - s.radius * s.radius;
    float discriminant = h * h - a * c;

    if (discriminant < 0.0) return false;
    float sq = sqrt(discriminant);

    // Try the near root first, then the far root.
    float root = (h - sq) / a;
    if (root < t_min || root > t_max) {
        root = (h + sq) / a;
        if (root < t_min || root > t_max) return false;
    }

    rec.t = root;
    rec.p = ray_at(r, rec.t);
    vec3 outward_normal = (rec.p - s.center) / s.radius;
    set_face_normal(rec, r, outward_normal);
    rec.mat_type    = s.mat_type;
    rec.albedo      = s.albedo;
    rec.fuzz_or_ior = s.fuzz_or_ior;
    return true;
}

// =============================================================
// AABB overlap test
// =============================================================
// Tests whether ray r intersects the axis-aligned bounding box
// defined by [aabb_min, aabb_max] within t ∈ [t_min, t_max].
// Uses the slab method (Smits 1998): test each axis pair,
// intersect the resulting intervals, reject if empty.

bool aabb_hit(vec3 aabb_min, vec3 aabb_max, Ray r, float t_min, float t_max) {
    for (int axis = 0; axis < 3; axis++) {
        float dir  = r.dir[axis];
        float orig = r.origin[axis];
        float lo   = aabb_min[axis];
        float hi   = aabb_max[axis];

        if (abs(dir) < 1e-8) {
            // Ray is nearly parallel to this slab.
            if (orig < lo || orig > hi) return false;
        } else {
            float invD = 1.0 / dir;
            float t0 = (lo - orig) * invD;
            float t1 = (hi - orig) * invD;
            if (t0 > t1) { float tmp = t0; t0 = t1; t1 = tmp; }
            t_min = max(t_min, t0);
            t_max = min(t_max, t1);
            if (t_max <= t_min) return false;
        }
    }
    return true;
}

// =============================================================
// BVH traversal — iterative, stack-based
// =============================================================
// We replicate the iterative bvh_hit_linear algorithm from
// hittable.odin. No recursion = no GLSL limitation.
//
// Stack holds node indices to visit. At each iteration:
//   1. Pop a node.
//   2. Test its AABB — skip if miss.
//   3. If leaf: test the sphere directly.
//   4. If internal: push both children.
//
// "closest" tracks the nearest hit found so far; AABB tests use
// it as t_max so we automatically cull nodes behind existing hits.

bool bvh_hit_scene(Ray r, float t_min, float t_max, out HitRecord closest_rec) {
    float closest = t_max;
    bool  hit_anything = false;

    // max depth 64 — sufficient for up to ~10^18 objects with balanced BVH;
    // exceeding it silently skips nodes (missing geometry).
    int stack[64];
    int stack_ptr = 0;
    stack[stack_ptr++] = 0; // start at root (index 0)

    while (stack_ptr > 0) {
        int idx = stack[--stack_ptr];
        if (idx < 0 || idx >= bvh_count) continue;

        BVHNode node = bvh_nodes[idx];

        // AABB test: skip this subtree if the ray misses the bounding box.
        if (!aabb_hit(node.aabb_min, node.aabb_max, r, t_min, closest)) continue;

        if (node.left_idx == -1) {
            // ── Leaf node ──
            // Decode sphere index: stored as -(obj_index + 1).
            int obj_idx = -(node.right_or_obj_idx + 1);
            if (obj_idx >= 0 && obj_idx < sphere_count) {
                HitRecord rec;
                if (hit_sphere(spheres[obj_idx], r, t_min, closest, rec)) {
                    closest     = rec.t;
                    closest_rec = rec;
                    hit_anything = true;
                }
            }
        } else {
            // ── Internal node ── push children (right first so left is popped first).
            if (node.right_or_obj_idx >= 0) stack[stack_ptr++] = node.right_or_obj_idx;
            if (node.left_idx          >= 0) stack[stack_ptr++] = node.left_idx;
        }
    }

    return hit_anything;
}

// =============================================================
// Material scatter functions
// =============================================================
// Each function takes the incoming ray and hit record, and returns
// true with (attenuation, scattered) if the material scatters.
// Returns false for pure absorption (path ends, contributes black).
//
// Adding a new material:
//   1. Add a MAT_* constant at the top.
//   2. Write a scatter_* function here.
//   3. Add a case in the switch inside path_trace().

// Lambertian (diffuse): scatter in a random direction near the normal.
// attenuation = albedo (material colour).
bool scatter_lambertian(vec3 albedo, HitRecord rec, inout uint seed,
                        out vec3 attenuation, out Ray scattered) {
    vec3 scatter_dir = rec.normal + rand_unit_vec3(seed);
    // Degenerate case: direction nearly zero — use normal instead.
    if (dot(scatter_dir, scatter_dir) < 1e-12) scatter_dir = rec.normal;
    scattered   = Ray(rec.p, scatter_dir);
    attenuation = albedo;
    return true;
}

// Metallic (specular reflection): reflect + fuzz perturbation.
// fuzz = 0 → perfect mirror; fuzz = 1 → very rough metal.
bool scatter_metallic(vec3 albedo, float fuzz, Ray r_in, HitRecord rec,
                      inout uint seed, out vec3 attenuation, out Ray scattered) {
    vec3 reflected = reflect(normalize(r_in.dir), rec.normal);
    reflected = normalize(reflected) + fuzz * rand_unit_vec3(seed);
    scattered   = Ray(rec.p, reflected);
    attenuation = albedo;
    // Ray scattered below the surface means no contribution.
    return dot(scattered.dir, rec.normal) > 0.0;
}

// Schlick approximation for Fresnel reflectance.
// Determines probability of reflection vs. refraction at an interface.
float schlick(float cosine, float ref_idx) {
    float r0 = (1.0 - ref_idx) / (1.0 + ref_idx);
    r0 = r0 * r0;
    return r0 + (1.0 - r0) * pow(1.0 - cosine, 5.0);
}

// Dielectric (glass / water): refract or reflect based on Snell's law
// and Fresnel reflectance (Schlick approximation).
bool scatter_dielectric(float ior, Ray r_in, HitRecord rec,
                        inout uint seed, out vec3 attenuation, out Ray scattered) {
    attenuation = vec3(1.0); // glass absorbs nothing
    float ri = rec.front_face ? (1.0 / ior) : ior;

    vec3  unit_dir = normalize(r_in.dir);
    float cos_theta = min(dot(-unit_dir, rec.normal), 1.0);
    float sin_theta = sqrt(1.0 - cos_theta * cos_theta);

    bool cannot_refract = ri * sin_theta > 1.0;
    vec3 direction;

    if (cannot_refract || schlick(cos_theta, ri) > rand(seed)) {
        direction = reflect(unit_dir, rec.normal);
    } else {
        direction = refract(unit_dir, rec.normal, ri);
    }

    scattered = Ray(rec.p, direction);
    return true;
}

// =============================================================
// Sky / background colour
// =============================================================
// Simple gradient from white (horizon) to sky blue (zenith).
// Mirrors the CPU implementation in ray_color().

vec3 sky_color(Ray r) {
    vec3 unit_dir = normalize(r.dir);
    float a = 0.5 * (unit_dir.y + 1.0);
    return mix(vec3(1.0), vec3(0.5, 0.7, 1.0), a);
}

// =============================================================
// Primary path tracing loop
// =============================================================
// Mirrors the recursive ray_color() but uses iteration.
//
// We track two accumulators:
//   throughput — multiplicative attenuation so far (starts at 1)
//   colour     — additive light contributions (starts at 0)
//
// At each bounce:
//   1. Test scene for intersection (BVH).
//   2. Scatter from the hit material (or terminate if absorbed).
//   3. throughput *= attenuation.
//   4. If no hit: colour += throughput * sky; break.

vec3 path_trace(Ray r, inout uint seed) {
    vec3 throughput = vec3(1.0);
    vec3 colour     = vec3(0.0);

    for (int depth = 0; depth < max_depth; depth++) {
        HitRecord rec;
        if (bvh_hit_scene(r, 0.001, 1e30, rec)) {
            vec3 attenuation;
            Ray  scattered;
            bool did_scatter;

            // Dispatch to the appropriate scatter function.
            // To add a new material: add MAT_* constant above and a case here.
            switch (rec.mat_type) {
            case MAT_LAMBERTIAN:
                did_scatter = scatter_lambertian(rec.albedo, rec, seed, attenuation, scattered);
                break;
            case MAT_METALLIC:
                did_scatter = scatter_metallic(rec.albedo, rec.fuzz_or_ior, r, rec, seed, attenuation, scattered);
                break;
            case MAT_DIELECTRIC:
                did_scatter = scatter_dielectric(rec.fuzz_or_ior, r, rec, seed, attenuation, scattered);
                break;
            default:
                did_scatter = false;
                break;
            }

            if (!did_scatter) {
                // Material absorbed the ray — path ends, no contribution.
                return colour;
            }

            throughput *= attenuation;
            r = scattered;
        } else {
            // Ray escaped the scene — accumulate sky light.
            colour += throughput * sky_color(r);
            return colour;
        }
    }

    // Max depth exceeded — return whatever we accumulated.
    return colour;
}

// =============================================================
// Main compute entry point
// =============================================================

void main() {
    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
    if (pixel.x >= width || pixel.y >= height) return;

    int pixel_idx = pixel.y * width + pixel.x;

    // ── Seed the RNG uniquely per (pixel, sample) ──────────
    uint pixel_index = uint(pixel_idx);
    uint sample_index = uint(current_sample);
    uint seed = pcg_hash(pixel_index ^ (sample_index * 2654435761u));
    // Warm up the RNG by discarding a few values.
    pcg(seed); pcg(seed);

    // ── Generate the primary ray ────────────────────────────
    // Antialiasing: jitter the sample within the pixel.
    vec2 jitter = rand2(seed) - 0.5;
    float fx = float(pixel.x) + jitter.x;
    float fy = float(pixel.y) + jitter.y;

    vec3 pixel_sample = pixel00_loc.xyz
                      + fx * pixel_delta_u.xyz
                      + fy * pixel_delta_v.xyz;

    // Depth of field: sample origin from defocus disk.
    vec3 ray_origin;
    float defocus_angle = defocus_disk_u.w;
    if (defocus_angle <= 0.0) {
        ray_origin = camera_center.xyz;
    } else {
        vec2 disk = rand_in_unit_disk(seed);
        ray_origin = camera_center.xyz
                   + disk.x * defocus_disk_u.xyz
                   + disk.y * defocus_disk_v.xyz;
    }

    Ray primary = Ray(ray_origin, pixel_sample - ray_origin);

    // ── Trace the path ──────────────────────────────────────
    vec3 colour = path_trace(primary, seed);

    // ── Accumulate into output buffer ───────────────────────
    // Each dispatch call adds one sample to the buffer.
    // The CPU reads back after all samples and divides by the count.
    pixels[pixel_idx] += vec4(colour, 0.0);
}
